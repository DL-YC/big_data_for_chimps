== Geo Data ==


[[quadkey]]
=== The Quadtile Grid System ===


Large-scale geodata processing in hadoop starts with the grid system, a simple butv very powerful idea.
put the map on a simple, flat Mercator projection- the one that geographers cringe, where you just directly map longitude and latitude to (X,Y) (footnote: somehow in naetiral speech people want to say "lat, long". You should instead say "lng, lat" -- it's consistent with the (X, Y) convention and also avoids using ´long´, a keyword in pig and other languages).
Now divide the world into four and make a Z pattern across them:

   1 -- 2
      /
     /
   3 -- 4

Within each of those, make a Z again:

image::images/quadkeys-nearby_points_are_nearby.png[Z-path of quadtiles]

As you go along, index each tile:

image::images/quadkeys-numbering-zl0-zl1.png[quadtile numbering]

This is a 1-d index into a 2-d space! What's more, nearby points in space are typically nearby in index value. By sorting all records by the quadtile they rest on, geographic locality falls out of numerical locality. Hadoop's fundamental locality operation (TODO: reword)

==== Converting points to quadkeys (quadtile indexes)

Each grid cell is contained in its parent


image::images/quadkeys-numbering-select_down.png[Tile index for central Texas]

You can also think of it as a tree:

image::images/quadkeys-3d-stack.png[Z-path of quad tiles]


The quadkey is a string of 2-bit tile selectors for a quadtile

@example
  infochimps_hq = Geo::Place.receive("Infochimps HQ", -97.759003, 30.273884)
  infochimps_hq.quadkey(8) # => "02313012"

Interesting quadtile properties:

* The quadkey length is its zoom level

* To zoom out (lower zoom level, larger quadtile), just truncate the
  quadkey: austin at ZL=8 has quadkey "02313012"; at ZL=3, "023"

* Nearby points typically have "nearby" quadkeys: up to the smallest
  tile that contains both, their quadkeys will have a common prefix.
  If you sort your records by quadkey,
  - Nearby points are nearby-ish on disk. (hello, HBase/Cassandra
    database owners!) This allows efficient lookup and caching of
    "popular" regions or repeated queries in an area.
  - the tiles covering a region can be covered by a limited, enumerable
    set of range scans. For map-reduce programmers, this leads to very
    efficient reducers

* The quadkey is the bit-interleaved combination of its tile ids:

      tile_x      58  binary  0  0  1  1  1  0  1  0
      tile_y      105 binary 0  1  1  0  1  0  0  1
      interleaved     binary 00 10 11 01 11 00 01 10
      quadkey                 0  2  3  1  3  0  1  2 #  "02313012"
      packed                 11718

      
* You can also form a "packed" quadkey -- the integer formed by interleaving the bits as shown above. At zoom level 15, the packed quadkey is a 30-bit unsigned integer -- meaning you can store it in a pig `int`; for languages with an `unsigned int` type, you can go to zoom level 16 before you have to use a less-efficient type. Zoom level 15 has a resolution of about one tile per kilometer (about 1.25 km/tile near the equator; 0.75 km/tile at London's latitude). It takes 1 billion tiles to tile the world at that scale. 

* a limited number of range scans suffice to cover any given area
* each grid cell's parents are a 2-place bit shift of the grid index itself.
  
References:

* http://msdn.microsoft.com/en-us/library/bb259689.aspx
* http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/
* http://wiki.openstreetmap.org/wiki/QuadTiles
* https://github.com/simplegeo/polymaps

=== Quadkey Ready Reference ===



image::images/quadkey_ref-zoom_levels.png[Quadtile properties and data storage sizes by zoom level]

Though quadtile properties do vary, the variance is modest within most of the inhabited world:

image::images/quadkey_ref-world_cities.png[Quadtile Properties for major world cities]

The (ref table) gives the full coordinates at every zoom level for our exemplar set.

image::images/quadkey_ref-full_props-by_zl.png[Coordinates at every zoom level for some exemplars]




==== Quadtile practicalities ====

===== Working with paths =====

The _smallest tile that fully encloses a set of points_ is given by the tile with the largest common quadtile prefix. For example, the University of Texas (quad `0231_3012_0331_1131`) and my office (quad `0231_3012_0331_1211`) are covered by the tile `0231_3012_0331_1`.

image::images/fu05-geographic-path-hq-to-ut.png[Path from Chimp HQ to UT campus]

When points cross major tile boundaries, the result is less pretty. Austin's airport (quad `0231301212221213`) shares only the zoom-level 8 tile `02313012`:

image::images/fu05-geographic-path-hq-to-airport.png[Path from Chimp HQ to AUS Airport]

=== K-means clustering to summarize ===

==== Reference for sizes and zooms ====

http://www.maptiler.org/google-maps-coordinates-tile-bounds-projection/







1 tile at Zoom 11 is about { ben white, research, 183, 360 } -

    ZL               11
    G         468,  843
    TMS       468, 1204
    QT      02313012122
    #tiles    4,194,304
    MB@10k       40,960 MB

1 tile at Zoom 12 is about {lake austin, rsrc, 183, mopac }

    ZL               12
    G         936, 1686
    TMS       936, 2409
    QT      023130121220
    #tiles   16,777,216
    MB@10k      163,840 MB

1 tile at Zoom 13 is { lake austin, 38th, I35, mopac }

    ZL               13
    G        1872, 3372
    TMS      1872, 4819
    QT      0231301212200
    #tiles   67,108,864
    MB@10k      655,360 MB              2**26 * 10 * 1024 / (1024 ** 2)

1 tile at Zoom 14 is { lake austin, 15th, I35, Lamar }

    ZL               14
    G        3743, 6745
    TMS      3743, 9638
    QT      02313012033113
    #tiles  268,435,456
    MB@10k    2,621,440

=== Map Points to Grid Cells ===

We started with an apology to geographers for our uncouth map projection? we will make it up a bit by having each grid cell be an increasingly better locally-flat approximation to the earths surface. this makes the math more complicated but the result id worth it.


The maximum latitude this projection covers is plus/minus `85.05112878` degrees. With apologies to the elves of chapter (TODO: ref), this is still well north of Alert, Canada, the northernmost populated place in the world (latitude 82.5 degrees, 817 km from the North Pole).


=== Grid Sizes and Sample Preparation ===


Always include as a mountweazel some places you're familiar with. It's much easier for me to think in terms of the distance from my house to downtown, or to Dallas, or to New York than it is to think in terms of zoom level 14 or 7 or 4


=== Map Boundaries to Grid Cells ===



=== Map Regions to Grid Cells ===

==== Adaptive Grid Size ====

The world is a big place, but we don't use all of it. Most of the world is water. Lots of it is Kansas.

We can use the grid system to very naturally describe multiscale data.

key things with an out-of-band
Quadkey 0112XX means "I carry the information for grids 011200, 011201, ... 011233".

Choose an upper bound for range, and decompose thing to that level -- so even if something applied to grid 0123XXX, but your upper raneg is 5 quads, you would duplicate that row as 01230XX, 01231XX, etc. (fn: this is a small penalty, since the grid scales exponentially.)
With the upper range as your partition key, and the whole quadkey is the sort key, you can now do joins

* read keys on each side until one key is equal to or a prefix of the other.
* emit combined record using the more specific of the two keys
* read the next record from the more-specific column,  until there's no overlap

Take each grid cell; if it needs subfeatures, divide it else emit directly.

You must emit high-level grid cells with the lsb filled with XX or something that sorts after a normal cell; this means that to find the value for a point,

* Find the corresponding tile ID,
* Index into the table to find the first tile whose ID is larger than the given one.
 This is why you must split in four parts

     00.00.00
     00.00.01
     00.00.10
     00.00.11
     00.01.--
     00.10.--
     00.11.00
     00.11.01
     00.11.10
     00.11.11
     01.--.--
     10.00.--
     10.01.--
     10.10.01
     10.10.10
     10.10.11
     10.10.00
     10.11.--

=== Weather Near You ===

==== Find the Voronoi Polygon for each Weather Station ====

==== Map Polygons to Grid Tiles ====



              +----------------------------+
              |                            |
              |              C             |
              |      ~~+---------\         |
              |     /  |          \       /
              |    /   |           \     /|
              |   /    |            \   / |
               \ /     |     B       \ /  |
                |      |              |   |
                |  A   +--------------'   |
                |      |                  |
                |      |     D            /
                |      |               __/
                 \____/ \             |
                         \____________,


            +-+-----------+-------------+--+------
            | |           |             |  |
            | |           |         C   |  |
      000x  | |   C  ~~+--+------\      |  |      0100
            | |     / A|B |  B    \     | /
            |_|____/___|__|________\____|/|_______
            | | C /    |  |         \ C / |
            |  \ /     |B |  B       \ /| |
      001x  |   |      |  |           | |D|       0110
            |   |  A   +--+-----------' | |
            |   |      |D |  D          | |
            +---+------+--+-------------+-/-------
            |   |  A   |D |            _|/
            |    \____/ \ |    D      | |
      100x  |            \|___________, |         1100
            |             |             |
            |             |             |
            +-------------+-------------+---------
                ^ 1000        ^ 1001

* Tile 0000: `[A, B, C   ]`
* Tile 0001: `[   B, C   ]`
* Tile 0010: `[A, B, C, D]`
* Tile 0011: `[   B, C, D]`

* Tile 0100: `[      C,  ]`
* Tile 0110: `[      C, D]`

* Tile 1000: `[A,       D]`
* Tile 1001: `[         D]`
* Tile 1100: `[         D]`

For each grid, also calculate the area each polygon covers within that grid.

Pivot:

* A:          `[ 0000       0010                   1000             ]`
* B:          `[ 0000 0001 0010 0011                               ]`
* C:          `[ 0000 0001 0010 0011 0100 0110                   ]`
* D:          `[             0010 0011       0110 1000 1001 1100 ]`


==== Map Observations to Grid Cells ====

Now join observations to grid cells and reduce each grid cell.

=== GeoJSON ===

Using polymaps to view results


=== Exercises ===

**Exercise 1**: Write a generic utility to do multiscale smoothing

Its input is a uniform sampling of values: a value for every grid cell at some zoom level.
However, lots of those values are similar.
Combine all grid cells whose values lie within a certain tolerance into

Example: merge all cells whose contents lie within 10% of each other

    00	10
    01	11
    02   9
    03   8
    10  14
    11  15
    12  12
    13  14
    20  19
    21  20
    22  20
    23  21
    30  12
    31  14
    32   8
    33   3

    10  11  14  18     .9.5. 14  18
     9   8  12  14     .   . 12  14
    19  20  12  14     . 20. 12  14
    20  21   8   3     .   .  8   3

**Exercise 2**:

